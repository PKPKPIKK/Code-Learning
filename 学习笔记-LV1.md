# Code-Learning

# 问题1：无src
    1.创建src目录
    2.转换src为Java认识的源代码
    在设置→项目结构→模块→新建→应用
    3.指定JDK24为
    和上级相同解决方法，在项目里
# 问题2：sout的区别
    1.System.out.println为先打印再换行
    2.System.out.print为只打印不换行

# 1、软件包的建立
    命名规则为公司域名的反向，示例：com.LT.Learning
    实际在文件管理器里观察为三级结构,分三层目录

# 2.HelloWorld
    代码内容要写在正确的位置{}
    单行注释快捷键：ctrl+/
    多行注释快捷键：ctrl+shift+/

# 3.字面量
    1.整数：int a=10;
    2.小数：double a=10.0;
    3.字符：char a='a'; (单引号，内容只有一个)
    4.布尔：boolean a=true;
    5.字符串：String a="hello world";   
    6.空类型：null
    注：定义的变量只在当前大括号内有效

# 4.数据类型
    1.基本数据类型
        1.int a = 10;byte,short,int,long;1,2,4,8(字节)；
        long类型，必须加L(一般写大写L)
        2.double a = 10.0;float,double;4,8(字节);
        float类型，必须加F(一般写大写F)
        3.char a = 'a';2(字节)；
        4.boolean a = true;1(字节)

# 6.标识符(代码中自己起的名字)
    1.变量命名规则(硬性要求)：
        1.只能使用字母、数字、下划线、$
        2.不能以数字开头
        3.不能使用关键字
        4.区分大小写
    2.软性建议：
        1.见名知意
        2.小驼峰命名法(变量)：
            一个单词全部小写
            第二个单词开始，每个单词首字母大写
        3.大驼峰命名法(类名)：
            每个单词首字母大写

# 7.键盘录入：
    //若Scanner是AI输入，则需要补齐开头的import，alt+p自动补齐
    1.Scanner sc = new Scanner(System.in);(会有提示；需要在开头引入库)
    2.sc.nextInt();
    3.sc.nextDouble();
    4.sc.next();

# 8.运算符
    1.算数运算符：+ - * / %(取余数)
    2.数字计算：(类型不一样不能运算，需要转到同类型的数据类型)
        隐式转换：不同类型进行计算，进行隐式转换(自动转换)，从取值范围小→大，变为同类型再进行计算
        若计算的数据类型为byte，会先自动转为int再进行运算
        强制转换：取值范围小→大，int a = 100;byte b = (byte)a;有弊端，会导致数据缺失，丢失精度
    3.字符运算符：字符会先转换为数值，再进行运算(查询ASCII码表)
    4.字符串运算符：+ 拼接字符串，任意数据+字符串都是拼接操作，并产生一个新的字符串
    5.自增、自减运算符：
        1.++a 先自增，再使用
        2.a++ 先使用，再自增
    6.赋值运算符：=；+=；-=；*=；/=；%=；运算玩完成，赋值给左侧的变量
    7.关系运算符：< >；<=；>=；==；!=
    8.逻辑运算符：& 逻辑与；| 逻辑或；! 逻辑非
        短路逻辑运算符：&& 逻辑与;||逻辑或,逻辑运算符的运算结果为true，则不会进行后面的运算
    9.三元运算符：条件 ? 运算1 : 运算2
    10.运算符优先级：
        小括号优先于所有运算符

# 9. 判断语句/if语句
    1.if(关系表达式){
        语句体;
      }
    2.if大括号的位置
      if大括号的省略
      小括号后不能有分号
      判断布尔类型的变量
      上述请参考ifDemo3
    3.if(关系表达式){
        语句体A;
      }else{
        语句体B;
      }
    4.if(关系表达式){
        语句体A;
      }else if(关系表达式){
        语句体B;
      }else {
        语句体C;
      }
    注：if有多个分支的时候，要把小范围的if语句放在前面

# 10.选择语句/switch语句
    1.switch(表达式){
        case 值1:
            语句体1;
            break;
            case 值2:
                语句体2;
                break;
                ……
      }
    2.表达式的数据类型：byte、short、int、char、枚举、String
    3.case:被表达式匹配的值
    4.break:跳出当前循环，结束switch语句
    5.default:没有匹配的case，执行default中的语句
    注：case、default没有标准上下之分，位置可以任意书写，但是为了标准，
    case从小到大依次书写，default一般放在最后
        case穿透：若忘记书写break，此时就会触发case穿透
                  匹配上了，就会执行匹配的case中的语句，遇到break就结束整个switch语句
                  若没有break，就继续执行下一个case中的语句，直到遇到break或者结束switch语句
        switch新特性：
                    箭头标签：不会有case穿透现象
                    case后可以跟多个值
                    switch可以有运行结果，结合yield

# 11.循环语句/for循环
    1.for(初始化语句;条件判断语句;条件控制语句){循环体语句}
    2.执行流程：初始化语句→条件判断语句→循环体语句→条件控制语句→条件判断语句→……
# 12.循环语句/while循环
    1.初始化语句
      while(条件判断语句){
        循环体语句;
        条件控制语句;
       }
# 13.循环语句/do while循环
    1.初始化语句
      do{
        循环体语句;
        条件控制语句;
      }while(条件判断语句);
    2.先执行后判断，循环至少执行一次
# 14.循环语句/高级
    1.无限循环：for(;;){}
                while(true){}
                do{}while(true);
    2.break:不能单独出现，只能出现在循环结构中或switch结构种；结束整个循环
    3.continue:不能单独出现，只能出现在循环结构中；结束本次循环，进入下一次循环
    4.循环嵌套:见looploop的例子
# 15.制表符
    1.制表符：\t
    2.详细见looploop.test1
# 16.数组
    1.定义：一种容器，存储一组相同类型的数据（相同类型，但是有隐式转换）
    2.静态初始化：int[] arr  = new int [] {a,b,c};（静态：在定义时赋确切的值）
                  int arr [] = {a,b,c};
    3.注：空间是连续的；一旦定义长度不可变
    4.元素的访问：数组名[索引值]（索引：从0开始，连续+1，不间断，是每一个小格子的编号）
    5.元素遍历：利用循环依次获取其中的元素,0---arr.length
    6.动态初始化：有默认初始化数据：0；0.0；false；null；/u0000
    7.索引越界：索引值必须>=0，索引值必须<数组的长度
    8.二维数组：
                静态初始化：数据类型[][] 数组名 = new 数据类型{{a,b,c}，{d,e,f}};
                            数据类型[][] 数组名 = {{a,b,c}，{d,e,f}}；
                动态初始化：数据类型[][] 数组名 = new 数据类型[行数][列数];
# 17.方法
    1.定义：是程序当中的独立单元，是最小的执行单元
    2.方法声明：public static  返回值类型 方法名(参数列表：形式参数){
                方法体;    
                return 返回值;
                }
    3.方法调用：方法名(参数列表：实际参数);
    4.方法重载：方法名相同，参数列表不同，根据参数列表来区分
                不同：参数个数不同；参数类型不同；参数顺序不同
                若有多个方法重构，但是你的参数列表不百分百匹配，就会报错(隐式转换不会执行)
# 18.内存地址
    1.32位操作地址：内存以32位的二进制表示：0x00000000(十六进制转换，方便阅读)
    2.64位操作地址：内存以64位的二进制表示：0x0000000000000000(十六进制转换，方便阅读)
    3.内存分配：栈内存：和方法有关，方法调用时，方法中的局部变量会分配到栈内存中；
                堆内存：new关键字在其中开辟空间并产生地址；
                方法区：记录字节码信息，存class字节码文件（只存储不运行；要运行就进栈运行）；
                本地方法栈：存放本地方法调用的参数；
                程序计数器：存放当前执行的字节码行号。
# 19.面向对象(利用对象进行软件开发)
    1.对象：把相关的数据和方法组织成一个整体来看待
    2.描述一类事物的类叫Javabean类；带有main方法的类叫测试类；
    3.数据安全问题：private :只可在本类中才可以访问
                    设置方法来判断然后赋值和访问,结合private就可以
    4.和数组类似，sout的是地址，要是在方法中用，会直接通过地址改变数值
# 20.this
    1.局部变量(方法内)和成员变量重名，根据就近原则
    2.this.name,就使得前面的是成员变量，避免和name重名出现的问题(区分成员变量和局部变量)
    3.本质：所在方法调用者的地址值
# 21.构造方法
    1.在创建对象的同时给成员变量初始化,有空参数构造方法和带参数构造方法，名字相同参数不同(方法的重载)
    2.public 类名(){类型 name;}
    3.没有返回值，构造方法没有返回值类型
    4.习惯：无论是否使用，都有手动书写无参构造方法，和带全部参数的构造方法(不书写无参构造方法，就会自动生成一个无参构造方法)
# 22.static关键词
    1.静态成员变量：被当前类所有的对象共享（不属于对象，属于类；随着类的加载而加载，优先于对象存在）
        共享：赋值只要赋值一次；只要有一个对象修改了静态变量，其他对象再次访问的时候就是修改后的结果了
    2.调用方式
        方法一：类名调用（推荐）
        方法二：对象名调用
    3.内存解析：会在static加载时，在方法区生成一个静态区（JDK8以前），（JDK8以后）在堆内存生成一个静态区
    4.静态只能访问静态，非静态可以调用所有，静态方法无this
# 23.final关键词
    1.修饰变量： final int x;
        常量：只能赋值一次，不能更改；名字大写，多个单词用下划线隔开。
    2.不管是什么数据类型，用final修饰，那其记录的数据就不可更改
# 24.枚举
    1.public enum 类名{}（创建对象的个数是有限个的）
    2.创建有限个枚举项
    3.每一个枚举项都是该类的对象,每一个对象都是通过构造方法创建出来的，第一行必须是枚举项
    4.枚举项默认用public static final修饰
    5.会自动生成values()获取本类所有的枚举项和valueOf()获取指定的一个枚举项;
